const n="merged.wasm",u=async o=>new Promise((a,t)=>{const s=new Worker(new URL("/wasmoptim/assets/binaryen-worker-qgpbsLcn.js",import.meta.url));s.addEventListener("message",async r=>{s.terminate();const{wasmFileAfter:i,error:m}=r.data;return m?t(new Error(m)):a({wasmFileAfter:i})}),s.postMessage({wasmFileBefore:o})});self.addEventListener("message",async o=>{try{const{default:a}=await import("./wasm-merge-lCF_iJz2.js"),{wasmFiles:t}=o.data,s=[],r=await a({print:()=>{},printErr:e=>s.push(e)}),i=t.map(async e=>{const g=await e.arrayBuffer();r.FS.writeFile(e.name,new Uint8Array(g))});await Promise.all(i);const l=[...t.map(e=>[e.name,e.name.replace(/\.wasm$/,"")]).flat(),"--rename-export-conflicts","--enable-multimemory","--enable-reference-types","-o",n];if(console.log("wasm-merge",l.join(" ")),r.callMain(l),s.length){self.postMessage({error:s.join(`
`)});return}const f=r.FS.readFile(n,{encoding:"binary"}),c=new File([f],n,{type:"application/wasm"});[...t.map(e=>e.name),n].forEach(r.FS.unlink),self.postMessage({status:{size:c.size}});const{wasmFileAfter:w,error:p}=await u(c);if(p){self.postMessage({error:p});return}self.postMessage({file:w})}catch(a){self.postMessage({error:a.message})}});
